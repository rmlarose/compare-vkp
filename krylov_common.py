from typing import Tuple, List
from dataclasses import dataclass
import numpy as np
import scipy.linalg as la
import qiskit
from qiskit.circuit.library import PauliEvolutionGate
from qiskit.qasm2 import dumps
import openfermion as of
import convert

def paulihedral_trotter_circuit(ham: of.QubitOperator, dt: float) -> qiskit.QuantumCircuit:
    """Get a circuit for time evolution with the Hamiltonian ham
    using a time step of length dt."""

    assert dt > 0.0

    psum_ham = of.transforms.qubit_operator_to_pauli_sum(ham)
    qiskit_ham = convert.cirq_pauli_sum_to_qiskit_pauli_op(psum_ham)

    circuit = qiskit.QuantumCircuit(qiskit_ham.num_qubits)
    gate = PauliEvolutionGate(qiskit_ham)
    circuit.append(gate, range(qiskit_ham.num_qubits))
    return circuit


def subspace_matrices(
    ham: of.QubitOperator, 
    state_prep_circuit: qiskit.QuantumCircuit, 
    evolution_circuit: qiskit.QuantumCircuit,
    d: int
) -> Tuple[np.ndarray, np.ndarray]:
    """Get the S and H matrices for the subsapce generated by
    realt time evolution for time tau, up to subspace dimension d.
    The subspace is generated by the unitary U = exp(-i H tau),
    wich we approximate by N steps of a first-order Trotter
    approximation.
    
    Arguments:
    ham - Hamiltonian of the system.
    state_prep_circuit - Circuit to prepare the reference state.
    evolution_circuit - time evolution circuit U to generate subsapce.
    tau - time for the evolution operator (not the trotter step, the time for U.)
    steps - Number of steps to make U.
    d - Subpsace dimension
    
    Returns:
    H - Hamiltonian projected into subspace.
    S - overlap matrix of subspace."""

    # Store the reference state to compute overlaps.
    reference_state = qiskit.quantum_info.Statevector(state_prep_circuit).data

    ham_cirq = of.transforms.qubit_operator_to_pauli_sum(ham)
    ham_matrix = ham_cirq.matrix()

    h = np.zeros((d, d), dtype=complex)
    s = np.zeros((d, d), dtype=complex)
    for k in range(d):
        # TODO Use Ashley Monatanaro's method?
        # Compute the state vector for U^d |ref>.
        total_ckt = state_prep_circuit.copy()
        for _ in range(k):
            total_ckt = total_ckt.compose(evolution_circuit)
        evolved_state = qiskit.quantum_info.Statevector(total_ckt).data
        overlap = np.vdot(reference_state, evolved_state)
        mat_elem = np.vdot(reference_state, ham_matrix @ evolved_state)
        # Assign all elements of S and H for which |i-j| = k.
        for i in range(d):
            for j in range(d):
                if i - j == k:
                    s[i, j] = overlap
                    h[i, j] = mat_elem
                if j - i == k:
                    s[i, j] = overlap.conjugate()
                    h[i, j] = mat_elem.conjugate()
    assert la.ishermitian(h)
    assert la.ishermitian(s)
    return h, s


def energy_vs_d(h, s, step:int = 1) -> Tuple[List[int], List[float]]:
    """Get energy vs. subspace dimension.
    If H and S are of dimension D, we can get the energy estimate
    for d < D by taking the upper left d x d blocks of H and S."""

    assert h.shape == s.shape
    assert h.shape[0] == h.shape[1]
    ds: List[int] = []
    energies: List[float] = []
    for d in range(1, h.shape[0], step):
        ds.append(d)
        lam, v = la.eig(h[:d, :d], s[:d, :d])
        energies.append(np.min(lam))
    return ds, energies


@dataclass 
class RTESubspaceResult:
    """Store the results of getting the H and S matrices."""
    tau: float
    nsteps: int
    h: np.ndarray
    s: np.ndarray
    ds: List[int]
    energies: List[float]
